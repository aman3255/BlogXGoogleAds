const BlogModel = require('../models/blog.model');

const createBlogPost = async (req, res) => {
    try {
        const {
            title,
            content,
            excerpt,
            photo,
            tags,
            category,
            status,
            metaDescription,
            adSettings
        } = req.body;

        // Basic validation
        if (!title || !content) {
            return res.status(400).json({
                success: false,
                message: "Title and content are required"
            });
        }

        // Get author from authenticated user (assuming authMiddleware sets req.user)
        const author = req.user.id;

        // Prepare blog data
        const blogData = {
            title: title.trim(),
            content,
            author,
            ...(excerpt && { excerpt: excerpt.trim() }), // Optional field
            ...(photo && { photo }), // Optional field
            ...(tags && { tags: Array.isArray(tags) ? tags : [tags] }), // Ensure tags is array
            ...(category && { category }),
            ...(status && { status }),
            ...(metaDescription && { metaDescription: metaDescription.trim() }),
            ...(adSettings && { adSettings })
        };

        // Create new blog post
        const newBlog = new BlogModel(blogData);
        await newBlog.save();

        // Populate author information for response
        await newBlog.populate('author', 'username fullName');

        // Response
        res.status(201).json({
            success: true,
            message: "Blog post created successfully",
            blog: {
                id: newBlog._id,
                title: newBlog.title,
                slug: newBlog.slug,
                content: newBlog.content,
                excerpt: newBlog.excerpt,
                photo: newBlog.photo,
                author: {
                    id: newBlog.author._id,
                    username: newBlog.author.username,
                    fullName: newBlog.author.fullName
                },
                tags: newBlog.tags,
                category: newBlog.category,
                status: newBlog.status,
                views: newBlog.views,
                likes: newBlog.likes,
                metaDescription: newBlog.metaDescription,
                adSettings: newBlog.adSettings,
                createdAt: newBlog.createdAt,
                updatedAt: newBlog.updatedAt
            }
        });

    } catch (error) {
        console.error("Error in createBlogPost:", error);

        // Handle validation errors
        if (error.name === 'ValidationError') {
            const validationErrors = Object.values(error.errors).map(err => err.message);
            return res.status(400).json({
                success: false,
                message: "Validation failed",
                errors: validationErrors
            });
        }

        // Handle duplicate slug error
        if (error.code === 11000 && error.keyPattern && error.keyPattern.slug) {
            return res.status(409).json({
                success: false,
                message: "Blog post with this title already exists. Please choose a different title."
            });
        }

        // Handle other errors
        res.status(500).json({
            success: false,
            message: "Internal server error"
        });
    }
};


const updateBlogPost = async (req, res) => {
    try {
        const { id } = req.params; // Blog post ID from URL
        const {
            title,
            content,
            excerpt,
            photo,
            tags,
            category,
            status,
            metaDescription,
            adSettings
        } = req.body;

        // Get the current user ID from auth middleware
        const currentUserId = req.user.id;

        // Find the blog post
        const existingBlog = await BlogModel.findById(id);
        if (!existingBlog) {
            return res.status(404).json({
                success: false,
                message: "Blog post not found"
            });
        }

        // Check if the current user is the author of the blog post
        if (existingBlog.author.toString() !== currentUserId) {
            return res.status(403).json({
                success: false,
                message: "You are not authorized to update this blog post"
            });
        }

        // Prepare update data (only include fields that are provided)
        const updateData = {};
        
        if (title !== undefined) {
            updateData.title = title.trim();
            // Reset slug if title is changed (will be regenerated by pre-save hook)
            updateData.slug = undefined;
        }
        if (content !== undefined) updateData.content = content;
        if (excerpt !== undefined) updateData.excerpt = excerpt ? excerpt.trim() : excerpt;
        if (photo !== undefined) updateData.photo = photo;
        if (tags !== undefined) {
            updateData.tags = Array.isArray(tags) ? tags : (tags ? [tags] : []);
        }
        if (category !== undefined) updateData.category = category;
        if (status !== undefined) updateData.status = status;
        if (metaDescription !== undefined) {
            updateData.metaDescription = metaDescription ? metaDescription.trim() : metaDescription;
        }
        if (adSettings !== undefined) updateData.adSettings = adSettings;

        // Update the blog post
        const updatedBlog = await BlogModel.findByIdAndUpdate(
            id,
            updateData,
            { 
                new: true, // Return updated document
                runValidators: true // Run schema validations
            }
        ).populate('author', 'username fullName');

        if (!updatedBlog) {
            return res.status(404).json({
                success: false,
                message: "Blog post not found"
            });
        }

        // Response
        res.status(200).json({
            success: true,
            message: "Blog post updated successfully",
            blog: {
                id: updatedBlog._id,
                title: updatedBlog.title,
                slug: updatedBlog.slug,
                content: updatedBlog.content,
                excerpt: updatedBlog.excerpt,
                photo: updatedBlog.photo,
                author: {
                    id: updatedBlog.author._id,
                    username: updatedBlog.author.username,
                    fullName: updatedBlog.author.fullName
                },
                tags: updatedBlog.tags,
                category: updatedBlog.category,
                status: updatedBlog.status,
                views: updatedBlog.views,
                likes: updatedBlog.likes,
                metaDescription: updatedBlog.metaDescription,
                adSettings: updatedBlog.adSettings,
                createdAt: updatedBlog.createdAt,
                updatedAt: updatedBlog.updatedAt
            }
        });

    } catch (error) {
        console.error("Error in updateBlogPost:", error);

        // Handle validation errors
        if (error.name === 'ValidationError') {
            const validationErrors = Object.values(error.errors).map(err => err.message);
            return res.status(400).json({
                success: false,
                message: "Validation failed",
                errors: validationErrors
            });
        }

        // Handle duplicate slug error
        if (error.code === 11000 && error.keyPattern && error.keyPattern.slug) {
            return res.status(409).json({
                success: false,
                message: "Blog post with this title already exists. Please choose a different title."
            });
        }

        // Handle invalid ObjectId error
        if (error.name === 'CastError') {
            return res.status(400).json({
                success: false,
                message: "Invalid blog post ID"
            });
        }

        // Handle other errors
        res.status(500).json({
            success: false,
            message: "Internal server error"
        });
    }
};

const deleteBlogPost = async (req, res) => {
    try {
        const { id } = req.params; // Blog post ID from URL
        const currentUserId = req.user.id; // Get current user ID from auth middleware

        // Validate the blog post ID format
        if (!id || !id.match(/^[0-9a-fA-F]{24}$/)) {
            return res.status(400).json({
                success: false,
                message: "Invalid blog post ID format"
            });
        }

        // Find the blog post first to check if it exists and get author info
        const blogPost = await BlogModel.findById(id);
        
        if (!blogPost) {
            return res.status(404).json({
                success: false,
                message: "Blog post not found"
            });
        }

        // Check if the current user is the author of the blog post
        if (blogPost.author.toString() !== currentUserId) {
            return res.status(403).json({
                success: false,
                message: "You are not authorized to delete this blog post"
            });
        }

        // Delete the blog post
        await BlogModel.findByIdAndDelete(id);

        // Response with success message
        res.status(200).json({
            success: true,
            message: "Blog post deleted successfully",
            deletedBlog: {
                id: blogPost._id,
                title: blogPost.title,
                slug: blogPost.slug,
                deletedAt: new Date()
            }
        });

    } catch (error) {
        console.error("Error in deleteBlogPost:", error);

        // Handle invalid ObjectId error
        if (error.name === 'CastError') {
            return res.status(400).json({
                success: false,
                message: "Invalid blog post ID"
            });
        }

        // Handle other database errors
        if (error.name === 'MongoServerError') {
            return res.status(500).json({
                success: false,
                message: "Database error occurred while deleting blog post"
            });
        }

        // Handle other errors
        res.status(500).json({
            success: false,
            message: "Internal server error"
        });
    }
};

// Alternative: Soft delete function (marks as deleted instead of removing)
const softDeleteBlogPost = async (req, res) => {
    try {
        const { id } = req.params;
        const currentUserId = req.user.id;

        // Validate the blog post ID format
        if (!id || !id.match(/^[0-9a-fA-F]{24}$/)) {
            return res.status(400).json({
                success: false,
                message: "Invalid blog post ID format"
            });
        }

        // Find and update the blog post status to 'archived'
        const blogPost = await BlogModel.findById(id);
        
        if (!blogPost) {
            return res.status(404).json({
                success: false,
                message: "Blog post not found"
            });
        }

        // Check authorization
        if (blogPost.author.toString() !== currentUserId) {
            return res.status(403).json({
                success: false,
                message: "You are not authorized to delete this blog post"
            });
        }

        // Update status to archived instead of deleting
        const updatedBlog = await BlogModel.findByIdAndUpdate(
            id,
            { status: 'archived' },
            { new: true }
        ).populate('author', 'username fullName');

        res.status(200).json({
            success: true,
            message: "Blog post archived successfully",
            blog: {
                id: updatedBlog._id,
                title: updatedBlog.title,
                slug: updatedBlog.slug,
                status: updatedBlog.status,
                author: {
                    id: updatedBlog.author._id,
                    username: updatedBlog.author.username,
                    fullName: updatedBlog.author.fullName
                },
                updatedAt: updatedBlog.updatedAt
            }
        });

    } catch (error) {
        console.error("Error in softDeleteBlogPost:", error);

        if (error.name === 'CastError') {
            return res.status(400).json({
                success: false,
                message: "Invalid blog post ID"
            });
        }

        res.status(500).json({
            success: false,
            message: "Internal server error"
        });
    }
};


const getBlogById = async (req, res) => {
    try {
        const { id } = req.params; // Blog post ID from URL

        // Validate the blog post ID format
        if (!id || !id.match(/^[0-9a-fA-F]{24}$/)) {
            return res.status(400).json({
                success: false,
                message: "Invalid blog post ID format"
            });
        }

        // Find the blog post by ID and populate author information
        const blogPost = await BlogModel.findById(id)
            .populate('author', 'username fullName')
            .select('-__v'); // Exclude version field

        if (!blogPost) {
            return res.status(404).json({
                success: false,
                message: "Blog post not found"
            });
        }

        // Check if blog is published or if user is the author (for draft access)
        const currentUserId = req.user?.id; // Optional: might not be authenticated
        const isAuthor = currentUserId && blogPost.author._id.toString() === currentUserId;
        
        // Only show published blogs to non-authors, or all blogs to authors
        if (blogPost.status !== 'published' && !isAuthor) {
            return res.status(403).json({
                success: false,
                message: "This blog post is not available"
            });
        }

        // Increment view count (only for published blogs and non-authors)
        if (blogPost.status === 'published' && !isAuthor) {
            await BlogModel.findByIdAndUpdate(id, { 
                $inc: { views: 1 } 
            });
            blogPost.views += 1; // Update local object for response
        }

        // Response with blog post data
        res.status(200).json({
            success: true,
            message: "Blog post retrieved successfully",
            blog: {
                id: blogPost._id,
                title: blogPost.title,
                slug: blogPost.slug,
                content: blogPost.content,
                excerpt: blogPost.excerpt,
                photo: blogPost.photo,
                author: {
                    id: blogPost.author._id,
                    username: blogPost.author.username,
                    fullName: blogPost.author.fullName
                },
                tags: blogPost.tags,
                category: blogPost.category,
                status: blogPost.status,
                views: blogPost.views,
                likes: blogPost.likes,
                metaDescription: blogPost.metaDescription,
                adSettings: blogPost.adSettings,
                createdAt: blogPost.createdAt,
                updatedAt: blogPost.updatedAt
            }
        });

    } catch (error) {
        console.error("Error in getBlogById:", error);

        // Handle invalid ObjectId error
        if (error.name === 'CastError') {
            return res.status(400).json({
                success: false,
                message: "Invalid blog post ID"
            });
        }

        // Handle other errors
        res.status(500).json({
            success: false,
            message: "Internal server error"
        });
    }
};

const getBlogBySlug = async (req, res) => {
    try {
        const { slug } = req.params; // Blog slug from URL

        // Validate slug
        if (!slug || slug.trim().length === 0) {
            return res.status(400).json({
                success: false,
                message: "Blog slug is required"
            });
        }

        // Find the blog post by slug and populate author information
        const blogPost = await BlogModel.findOne({ slug: slug.toLowerCase() })
            .populate('author', 'username fullName')
            .select('-__v');

        if (!blogPost) {
            return res.status(404).json({
                success: false,
                message: "Blog post not found"
            });
        }

        // Check if blog is published or if user is the author
        const currentUserId = req.user?.id;
        const isAuthor = currentUserId && blogPost.author._id.toString() === currentUserId;
        
        if (blogPost.status !== 'published' && !isAuthor) {
            return res.status(403).json({
                success: false,
                message: "This blog post is not available"
            });
        }

        // Increment view count (only for published blogs and non-authors)
        if (blogPost.status === 'published' && !isAuthor) {
            await BlogModel.findByIdAndUpdate(blogPost._id, { 
                $inc: { views: 1 } 
            });
            blogPost.views += 1;
        }

        // Response
        res.status(200).json({
            success: true,
            message: "Blog post retrieved successfully",
            blog: {
                id: blogPost._id,
                title: blogPost.title,
                slug: blogPost.slug,
                content: blogPost.content,
                excerpt: blogPost.excerpt,
                photo: blogPost.photo,
                author: {
                    id: blogPost.author._id,
                    username: blogPost.author.username,
                    fullName: blogPost.author.fullName
                },
                tags: blogPost.tags,
                category: blogPost.category,
                status: blogPost.status,
                views: blogPost.views,
                likes: blogPost.likes,
                metaDescription: blogPost.metaDescription,
                adSettings: blogPost.adSettings,
                createdAt: blogPost.createdAt,
                updatedAt: blogPost.updatedAt
            }
        });

    } catch (error) {
        console.error("Error in getBlogBySlug:", error);
        res.status(500).json({
            success: false,
            message: "Internal server error"
        });
    }
};

const getBlogForEdit = async (req, res) => {
    try {
        const { id } = req.params;
        const currentUserId = req.user.id; // Required authentication

        if (!id || !id.match(/^[0-9a-fA-F]{24}$/)) {
            return res.status(400).json({
                success: false,
                message: "Invalid blog post ID format"
            });
        }

        const blogPost = await BlogModel.findById(id)
            .populate('author', 'username fullName')
            .select('-__v');

        if (!blogPost) {
            return res.status(404).json({
                success: false,
                message: "Blog post not found"
            });
        }

        // Only author can access for editing
        if (blogPost.author._id.toString() !== currentUserId) {
            return res.status(403).json({
                success: false,
                message: "You are not authorized to edit this blog post"
            });
        }

        // Don't increment views for editing
        res.status(200).json({
            success: true,
            message: "Blog post retrieved for editing",
            blog: {
                id: blogPost._id,
                title: blogPost.title,
                slug: blogPost.slug,
                content: blogPost.content,
                excerpt: blogPost.excerpt,
                photo: blogPost.photo,
                author: {
                    id: blogPost.author._id,
                    username: blogPost.author.username,
                    fullName: blogPost.author.fullName
                },
                tags: blogPost.tags,
                category: blogPost.category,
                status: blogPost.status,
                views: blogPost.views,
                likes: blogPost.likes,
                metaDescription: blogPost.metaDescription,
                adSettings: blogPost.adSettings,
                createdAt: blogPost.createdAt,
                updatedAt: blogPost.updatedAt
            }
        });

    } catch (error) {
        console.error("Error in getBlogForEdit:", error);

        if (error.name === 'CastError') {
            return res.status(400).json({
                success: false,
                message: "Invalid blog post ID"
            });
        }

        res.status(500).json({
            success: false,
            message: "Internal server error"
        });
    }
};



module.exports = {
    createBlogPost,
    updateBlogPost,
    deleteBlogPost,
    getBlogById,
    softDeleteBlogPost,
    getBlogBySlug,
    getBlogForEdit
}